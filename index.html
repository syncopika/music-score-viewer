<html>

<head>
	<script src="AudioManager.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js" integrity="sha512-Z8CqofpIcnJN80feS2uccz+pXWgZzeKxDsDNMD/dJ6997/LSRY+W4NmEt9acwR+Gt9OHN0kkI1CTianCwoqcjQ==" crossorigin="anonymous"></script>
	<style>
		body, #content, #toolbar {
			text-align: center;
			font-family: sans-serif;
		}
		
		canvas {
			border: 1px solid #000;
		}
		
		#buttons {
			margin: 3%;
		}
		
		#container {
			display: grid;
			grid-template-columns: 50% 50%; /* 2 columns */
		}
		
		#content {
			grid-column-start: 1;
		}
		
		#toolbar {
			grid-column-start: 2;
		}
		
		span {
			font-size: 12px;
		}
	</style>
</head>

<body>
	<h3> music score viewer <span><a href="https://github.com/syncopika/music-score-viewer">src</a></span></h3>
	<div id="container">
		<div id='content'>
			<div>
			  <!--
			  <button id="prev">Previous</button>
			  <button id="next">Next</button>
			  &nbsp; &nbsp;
			  -->
			  <span>page: <span id="page_num"></span> / <span id="page_count"></span></span>
			</div>

			<canvas id="the-canvas"></canvas>
		</div>
		<div id='toolbar'>
			<div id="buttons">
				<button id='playMusic' data-playing="false" role="switch" aria-checked="false">
					play
				</button>
				<button id='stopMusic' aria-checked="false">
					stop
				</button>
			</div>
		</div>
	</div>
</body>

<script>
	// copy-pasted from https://mozilla.github.io/pdf.js/examples/index.html#interactive-examples
	
	// If absolute URL from the remote server is provided, configure the CORS
	// header on that server.
	var url = 'music/rustic_inn_bgm/rustic inn bgm idea.pdf'; // bpm: 165

	// Loaded via <script> tag, create shortcut to access PDF.js exports.
	var pdfjsLib = window['pdfjs-dist/build/pdf'];

	// The workerSrc property shall be specified.
	pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";

	var pdfDoc = null,
		pageNum = 1,
		pageRendering = false,
		pageNumPending = null,
		scale = 1.1,
		canvas = document.getElementById('the-canvas'),
		ctx = canvas.getContext('2d');

	/**
	 * Get page info from document, resize canvas accordingly, and render page.
	 * @param num Page number.
	 */
	function renderPage(num) {
	  pageRendering = true;
	  // Using promise to fetch the page
	  pdfDoc.getPage(num).then(function(page) {
		var viewport = page.getViewport({scale});
		canvas.height = viewport.height;
		canvas.width = viewport.width;

		// Render PDF page into canvas context
		var renderContext = {
		  canvasContext: ctx,
		  viewport: viewport
		};
		var renderTask = page.render(renderContext);

		// Wait for rendering to finish
		renderTask.promise.then(function() {
		  pageRendering = false;
		  if (pageNumPending !== null) {
			// New page rendering is pending
			renderPage(pageNumPending);
			pageNumPending = null;
		  }
		});
	  });

	  // Update page counters
	  document.getElementById('page_num').textContent = num;
	}

	/**
	 * If another page rendering in progress, waits until the rendering is
	 * finished. Otherwise, executes rendering immediately.
	 */
	function queueRenderPage(num) {
	  if (pageRendering) {
		pageNumPending = num;
	  } else {
		renderPage(num);
	  }
	}

	/**
	 * Displays previous page.
	function onPrevPage() {
	  if (pageNum <= 1) {
		return;
	  }
	  pageNum--;
	  queueRenderPage(pageNum);
	}
	document.getElementById('prev').addEventListener('click', onPrevPage);
	*/
	
	/**
	 * Displays next page.
	function onNextPage() {
	  if (pageNum >= pdfDoc.numPages) {
		return;
	  }
	  pageNum++;
	  queueRenderPage(pageNum);
	}
	document.getElementById('next').addEventListener('click', onNextPage);
	*/
	
	/**
	 * Asynchronously downloads PDF.
	 */
	pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
	  pdfDoc = pdfDoc_;
	  document.getElementById('page_count').textContent = pdfDoc.numPages;

	  // Initial/first page rendering
	  renderPage(pageNum);
	});
	
	const trackPaths = {
		"flute": "music/rustic_inn_bgm/rusticinn-bar-idea2-edit-flute.ogg",
		"piccolo": "music/rustic_inn_bgm/rusticinn-bar-idea2-edit-piccolo.ogg",
		"violin": "music/rustic_inn_bgm/rusticinn-bar-idea2-edit-violin.ogg",
		"guitar": "music/rustic_inn_bgm/rusticinn-bar-idea2-edit-guitar.ogg",
		"harp": "music/rustic_inn_bgm/rusticinn-bar-idea2-edit-harp.ogg",
	};
	
	const notes = [
		"This piece was composed as background music for an inn in an upcoming MMORPG.",
		"The score was generated from a mmp file (LMMS) via my <a href=\"https://github.com/syncopika/mmp-to-MusicXML\">converter</a> and exported as .pdf from MuseScore without any modifications.",
		"As you can see, the score definitely needs some cleanup :)",
	];
	
	// sync page flipping with time progressed for music playback
	let reqAnimFrame = window.requestAnimationFrame;
	let cancelAnimFrame = window.cancelAnimationFrame;
	let reqId;
	let lastTime;
	let currTimeDiff = 0;
	let currPage = 1;
	
	// when to go to next page
	const timeMarkers = {
		1: 13,
		2: 24,
		3: 33,
		4: 44,
		5: 54,
		6: 61,
		7: 72,
		8: 81,
	};
	
	function step(timestamp){
		// we don't care about the timestamp requestAnimationFrame uses
		// since we'll rely on audioContext's timer instead
		let diff = audioContext.currentTime - lastTime;

		if(diff >= timeMarkers[currPage]){
			console.log("" + timeMarkers[currPage] + ": need to go to page " + currPage + "!");
			if(currPage < Object.keys(timeMarkers).length){
				queueRenderPage(++currPage); // make sure render calls don't collide, which would cause errors
			}else{
				// we're at the last page. stop the cycle.
				console.log("reached the end of the score");
				cancelAnimFrame(reqId);
				currTimeDiff = 0;
				currPage = 1;
				return;
			}
		}
		reqId = reqAnimFrame(step);
	}
	
	const playButton = document.querySelector('#playMusic');
	
	const audioManager = new AudioManager(trackPaths, playButton);
	audioManager.updateDOM(document.getElementById("toolbar"));
	audioManager.addNotes(document.getElementById("toolbar"), notes);
	
	const audioContext = audioManager.audioContext;
	
	playButton.addEventListener("click", function(evt){
		if(audioContext.state === 'suspended'){
			audioContext.resume();
		}
		if(this.dataset.playing === 'false'){
			this.dataset.playing = 'true';
			evt.target.textContent = "pause";
			
			// check if currTimeDiff is 0. if yes, set lastTime to currentTime
			// if not, use currTimeDiff to set lastTime
			if(currTimeDiff){
				lastTime = audioContext.currentTime - currTimeDiff;
			}else{
				// starting from the beginning
				queueRenderPage(currPage); // should be page 1
				lastTime = audioContext.currentTime;
			}
			
			audioManager.play();
			reqId = reqAnimFrame(step);
		}else{
			audioManager.pause();
			this.dataset.playing = 'false';
			evt.target.textContent = "play";
			cancelAnimFrame(reqId);
			
			// get curr time diff
			currTimeDiff = audioContext.currentTime - lastTime;
		}
	}, false);
	
	const stopButton = document.querySelector('#stopMusic');
	stopButton.addEventListener("click", function(evt){
		// stop playing and rewind audio to the beginning
		cancelAnimFrame(reqId);
		currTimeDiff = 0;
		currPage = 1;
		audioManager.stop();
	}, false);
	
</script>

</html>